<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/blog/libs/katex/katex.min.css"> <link rel=stylesheet  href="/blog/libs/highlight/styles/monokai-sublime.min.css"> <script src="https://kit.fontawesome.com/1966c00f87.js" crossorigin=anonymous ></script> <link rel=stylesheet  href="/blog/css/franklin.css"> <link rel=stylesheet  href="/blog/css/tufte.css"> <link rel=stylesheet  href="/blog/css/latex.css"> <link rel=stylesheet  href="/blog/css/adjust.css"> <title>Problema 1</title> <div id=layout > <div id=menu > <ul> <li><a style="font-size:larger;" href=https://github.com/marcoherrera-s><i class="fa-brands fa-github"></i></a> <li><a style="font-size:larger;" href=https://letterboxd.com/marcoherrera/><i class="fa-brands fa-letterboxd" style="color: #c01c28;"></i></a> <li><a style="font-size:larger;" href=https://www.goodreads.com/user/show/71696585-marco-herrera><i class="fa-brands fa-goodreads"></i></a> <li><a href="/blog/"><i class="fa-duotone fa-solid fa-house-chimney fa-xs"></i> <li><a href="/blog/menu1">Física </a> <li><a href="/blog/menu2/">Miscelánea</a> <li><a href="/blog/menu3/">Extra</a> <li><a href="/blog/menu4/">Otro</a> </ul> </div> <div id=main > <link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel=stylesheet > <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@700&display=swap" rel=stylesheet > <meta name=viewport  content="width=device-width, initial-scale=1"> <div class=franklin-content ><h1 id=problema ><a href="#problema" class=header-anchor >Problema</a></h1> <p>A veces, al resolver problemas de física, algunas de las cosas que más me han molestado es: una, sufrir por la <em>talacha</em> y dos; no hay dos.</p> <p>A ver, como físicos, siempre nos vamos a enfrentar a la talacha, a veces es el pan de cada día. No hay manera de terminar con ella, pero sí de hacerla más soportable.</p> <p>Entonces, lo que haremos hoy, será resolver uno de esos problemas que requeriría un buen arrastre del lápiz, pero sin usar el lápiz.</p> <p>El problema es el siguiente:</p> <ol> <li><p>El punto A de una barra <em>AB</em> se puede mover sin fricción a lo largo de una línea horizontal &#40;<em>eje x</em>&#41;. La barra es homogénea de masa <em>m</em> y longitud <em>l</em>. Se mueve en un plano vertical donde puede rotar libremente alrededor de <em>A</em>. Sobre <em>A</em> se ejerce una fuerza periódica en el eje horizontal \(F_x = \frac{1}{3} mg \cos(\Omega t) \), donde \(\Omega^2 = \frac{g}{l}\). Encontrar las ecuaciones de movimiento y resolverlas asumiendo que el ángulo \(\theta\) y la velocidad angular \(\dot{\theta}\) son pequeños. Usar las condiciones iniciales \(x(0) = \dot{x}(0) = 0 \) y \( \theta(0) = \dot{\theta}(0) \).</p> </ol> <img src="/blog/assets/problema.png" alt=""> <p>Lo primero que haremos será importar la primera paquetería que vamos a usar.</p> <p>Para la talacha usaremos SymPy, esta es una paquetería de Python que estamos llamando desde Julia, la usaremos para los cálculos simbólicos.</p> <pre><code class=language-julia >using SymPy</code></pre>
<p>Comenzamos definiendo nuestras variables y nuestras funciones. Para entender rápidamente cuáles serán variables y cuáles funciones, primero hay que tener una idea clara de los grados de libertad de nuestro sistema y de las <a href="https://en.wikipedia.org/wiki/Canonical_coordinates">coordenadas canónicas</a>, entonces, observando el sistema podemos concluir que las coordenadas canónicas serán la distancia en \(x\) y el ángulo \(\theta\) en el cual está rotando la barra.</p>
<p>Como en nuestro problema estamos lidiando con un sólido rígido, entonces nos interesan las coordenadas de su centro de masa: \(x_{cm}\) y \(y_{cm}\).</p>
<p>\(m\) es la masa, \(g\) la gravedad, \(l\) la longitud de la barra, \(t\) el tiempo.</p>
<pre><code class=language-julia >@syms m g y_cm x_cm l t  # Así definimos variables
θ &#61; SymFunction&#40;&quot;θ&quot;&#41;&#40;t&#41;  # Así definimos funciones
x &#61; SymFunction&#40;&quot;x&quot;&#41;&#40;t&#41;</code></pre>
<p>Ahora necesitamos definir nuestras derivadas para cada una de nuestras funciones, esto para que nos sean más fáciles algunas operaciones futuras.</p>
<pre><code class=language-julia >xdot &#61; diff&#40;x, t&#41;
xddot &#61; diff&#40;xdot, t&#41;
thetadot &#61; diff&#40;θ, t&#41;
thetaddot &#61; diff&#40;thetadot, t&#41;</code></pre>
<p>Obtenemos las coordenadas del centro de masa de la barra:</p>
<pre><code class=language-julia >x_cm &#61; x &#43; l//2 * sin&#40;θ&#41;</code></pre>
\(\frac{l \sin{\left(θ{\left(t \right)} \right)}}{2} + x{\left(t \right)}\)
<pre><code class=language-julia >y_cm &#61; l//2*cos&#40;θ&#41;</code></pre>
\(\frac{l \cos{\left(θ{\left(t \right)} \right)}}{2}\)
<p>Derivamos nuestras variables haciendo:</p>
<pre><code class=language-julia >x_cmd &#61; diff&#40;x_cm, t&#41;</code></pre>
\(\frac{l \cos{\left(θ{\left(t \right)} \right)} \frac{d}{d t} θ{\left(t \right)}}{2} + \frac{d}{d t} x{\left(t \right)}\)
<pre><code class=language-julia >y_cmd &#61; diff&#40;y_cm, t&#41;</code></pre>
\(- \frac{l \sin{\left(θ{\left(t \right)} \right)} \frac{d}{d t} θ{\left(t \right)}}{2}\)
<p>El siguiente paso es obtener la energía cinética, al tratar con un sólido rígido, sabemos que la energía cinética es de la siguiente forma: \(T = T_{cm} + T_{rotacional}\). Y es aquí en donde empezaría la talacha si tuviéramos que arrastrar el lápiz. Pero hoy no. Comencemos con \(T_{cm}\), esta está fácil, sabemos muy bien que \(T_{cm} = \frac{1}{2} m ( \dot{x_{cm}}^2 + \dot{y_{cm}}^2 ) \), entonces:</p>
<pre><code class=language-julia >T_cm &#61; 1//2 * m * &#40;x_cmd^2 &#43; y_cmd^2&#41;</code></pre>
\(\frac{m \left(\frac{l^{2} \sin^{2}{\left(θ{\left(t \right)} \right)} \left(\frac{d}{d t} θ{\left(t \right)}\right)^{2}}{4} + \left(\frac{l \cos{\left(θ{\left(t \right)} \right)} \frac{d}{d t} θ{\left(t \right)}}{2} + \frac{d}{d t} x{\left(t \right)}\right)^{2}\right)}{2}\)
<p>Como podemos ver, aún no está tan bien, personas inteligentes como nosotros hubieramos usado la identidad \(\sin^2 x + \cos^2 x = 1\)</p>
<p>Eso no es problema, podemos hacer simplemente:</p>
<pre><code class=language-julia >T_cm &#61; simplify&#40;expand&#40;T_cm&#41;&#41;</code></pre>
\(\frac{m \left(l^{2} \left(\frac{d}{d t} θ{\left(t \right)}\right)^{2} + 4 l \cos{\left(θ{\left(t \right)} \right)} \frac{d}{d t} x{\left(t \right)} \frac{d}{d t} θ{\left(t \right)} + 4 \left(\frac{d}{d t} x{\left(t \right)}\right)^{2}\right)}{8}\)
<p>Y damos gracias no haber hecho esa talachita.</p>
<p>Nuestro siguiente paso es obtener la energía cinética rotacional. Para esta sabemos que \(T_{rot} = \frac{1}{2} \omega I_{cm} \omega\), aquí estamos suponiento que \(I_{cm}\) es el tensor de inercia para ejes en el cuerpo respecto al centro de masa, este tensor, si es que la vida no nos odia demasiado aún, la mayoría de las veces es dado en problemas de este tipo. Continuando, \(\omega\) es la velocidad angular, nuestro cuerpo rota respecto al ángulo \(\theta\), por lo tanto, con la regla de la mano derecha tendríamos: \(\omega = \dot{\theta} \hat{z}\).</p>
<pre><code class=language-julia >I &#61; sympy.diag&#40;0, m*l^2 // 12, m*l^2 // 12&#41;</code></pre>
\(\begin{bmatrix} 0 & 0 & 0 \\ 0 & \frac{l^2 m}{12} & 0 \\ 0 & 0 & \frac{l^2 m}{12} \end{bmatrix}\)
<pre><code class=language-julia >ω &#61; Matrix&#40;&#91;0 0 diff&#40;θ, t&#41;&#93;&#41;</code></pre>
\(\omega = \begin{bmatrix} 0 & 0 & \frac{d\theta}{dt} \end{bmatrix}\)
<pre><code class=language-julia >T_rot &#61; &#40;1//2&#41;*ω*I*ω.T # .T para trasponer la matriz y poder hacer la operación

T_rot &#61; T_rot&#91;1&#93;</code></pre>
\(\frac{l^{2} m \left(\frac{d}{d t} θ{\left(t \right)}\right)^{2}}{24}\)
<p>Finalmente, sumamos nuestras dos energías cinéticas y obtenemos la energía cinética total.</p>
<pre><code class=language-julia >T &#61; T_cm &#43; T_rot</code></pre>
\(\frac{l^{2} m \left(\frac{d}{d t} θ{\left(t \right)}\right)^{2}}{24} + \frac{m \left(l^{2} \left(\frac{d}{d t} θ{\left(t \right)}\right)^{2} + 4 l \cos{\left(θ{\left(t \right)} \right)} \frac{d}{d t} x{\left(t \right)} \frac{d}{d t} θ{\left(t \right)} + 4 \left(\frac{d}{d t} x{\left(t \right)}\right)^{2}\right)}{8}\)
<p>La expandimos, para que no se vea tan grosera.</p>
<pre><code class=language-julia >T &#61; expand&#40;T&#41;</code></pre>
\(\frac{l^{2} m \left(\frac{d}{d t} θ{\left(t \right)}\right)^{2}}{6} + \frac{l m \cos{\left(θ{\left(t \right)} \right)} \frac{d}{d t} x{\left(t \right)} \frac{d}{d t} θ{\left(t \right)}}{2} + \frac{m \left(\frac{d}{d t} x{\left(t \right)}\right)^{2}}{2}\)
<p>Ahora definimos una nueva variable, \(\Omega\), que es la frecuencia de la fuerza que se aplica en el eje x.</p>
<pre><code class=language-julia >@syms Ω</code></pre>
<p>Para obtener la energía potencial, tenemos que sumar la que es debido a la gravedad, y el potencial asociado a la fuerza. Lo obtenemos recordando que: \(U(\mathbf{x}) = -\int \mathbf{F}(\mathbf{x}) \cdot d\mathbf{x}\)</p>
<p>Por lo tanto:</p>
<pre><code class=language-julia >U &#61; -&#40;m*g*l//2&#41;*cos&#40;θ&#41; - integrate&#40;1//3 * m*g*cos&#40;Ω*t&#41;, x&#41;
U &#61; simplify&#40;U&#41;</code></pre>
\(- \frac{g m \left(3 l \cos{\left(θ{\left(t \right)} \right)} + 2 x{\left(t \right)} \cos{\left(t Ω \right)}\right)}{6}\)
<p>Finalmente ya tenemos todo para obtener el Lagrangiano, entonces:</p>
<pre><code class=language-julia >L &#61; T - U</code></pre>
\(\frac{g m \left(3 l \cos{\left(θ{\left(t \right)} \right)} + 2 x{\left(t \right)} \cos{\left(t Ω \right)}\right)}{6} + \frac{l^{2} m \left(\frac{d}{d t} θ{\left(t \right)}\right)^{2}}{6} + \frac{l m \cos{\left(θ{\left(t \right)} \right)} \frac{d}{d t} x{\left(t \right)} \frac{d}{d t} θ{\left(t \right)}}{2} + \frac{m \left(\frac{d}{d t} x{\left(t \right)}\right)^{2}}{2}\)
<p>Obtenemos las ecuaciones de Euler - Lagrange, tal que: \(\frac{d}{dt} \left( \frac{\partial L}{\partial \dot{q}_i} \right) - \frac{\partial L}{\partial q_i} = 0\)</p>
<p>Para \(x\):</p>
<pre><code class=language-julia >ELX &#61; diff&#40;diff&#40;L, xdot&#41;, t&#41; - diff&#40;L, x&#41;</code></pre>
\(- \frac{g m \cos{\left(t Ω \right)}}{3} - \frac{l m \sin{\left(θ{\left(t \right)} \right)} \left(\frac{d}{d t} θ{\left(t \right)}\right)^{2}}{2} + \frac{l m \cos{\left(θ{\left(t \right)} \right)} \frac{d^{2}}{d t^{2}} θ{\left(t \right)}}{2} + m \frac{d^{2}}{d t^{2}} x{\left(t \right)}\)
<p>Para \(\theta\):</p>
<pre><code class=language-julia >ELθ &#61; diff&#40;diff&#40;L, thetadot&#41;, t&#41; - diff&#40;L, θ&#41;</code></pre>
\(\frac{g l m \sin{\left(θ{\left(t \right)} \right)}}{2} + \frac{l^{2} m \frac{d^{2}}{d t^{2}} θ{\left(t \right)}}{3} + \frac{l m \cos{\left(θ{\left(t \right)} \right)} \frac{d^{2}}{d t^{2}} x{\left(t \right)}}{2}\)
<p>Ahora despejamos para \(\frac{d^{2}}{d t^{2}} x\) de la siguiente forma:</p>
<pre><code class=language-julia >sol_1 &#61; solve&#40;ELX, xddot&#41;

sol_1&#91;1&#93;</code></pre>
\(\frac{g \cos{\left(t Ω \right)}}{3} + \frac{l \sin{\left(θ{\left(t \right)} \right)} \left(\frac{d}{d t} θ{\left(t \right)}\right)^{2}}{2} - \frac{l \cos{\left(θ{\left(t \right)} \right)} \frac{d^{2}}{d t^{2}} θ{\left(t \right)}}{2}\)
<p>Y para \(\frac{d^{2}}{d t^{2}} θ\) :</p>
<pre><code class=language-julia >sol_2 &#61; solve&#40;ELθ, thetaddot&#41;
sol_2&#91;1&#93;</code></pre>
\(- \frac{3 g \sin{\left(θ{\left(t \right)} \right)} + 3 \cos{\left(θ{\left(t \right)} \right)} \frac{d^{2}}{d t^{2}} x{\left(t \right)}}{2 l}\)

<p>Muy bien, ya tenemos nuestras ecuaciones de movimiento, ahora nos toca resolverlas. El problema nos pide asumir ángulos pequeños, esto porque así nos libraríamos de varios términos feos, porque a veces trabajar analíticamente con las ecuaciones de movimiento que obtenemos no sólo es difícil, puede resultar imposible. </p>
<p>Pero aquí no nos estamos manchando las manos, y además tenemos nuestras poderosas computadoras, entonces resolvamos como dios manda. </p>
<p>Empezamos importando las siguientes paqueterías de Julia:</p>
<pre><code class=language-julia >using DifferentialEquations, Plots</code></pre>
<p>Definimos nuestros parámetros, la gravedad de nuestro planeta, una longitud de 1.0, y la frecuencia definida como el problema nos dice. Además el span de tiempo para el cual queremos resolver la ecuación, en forma de tupla. </p>
<pre><code class=language-julia >params &#61; &#40;9.81, 1.0, sqrt&#40;9.81/1.0&#41;&#41;
tspan &#61; &#40;0.0, 10.0&#41;</code></pre>
<p>Recordamos los dos monstruos que acabamos de obtener:</p>
\(\frac{d^{2}}{d t^{2}} x = \frac{g \cos{\left(t Ω \right)}}{3} + \frac{l \sin{\left(θ{\left(t \right)} \right)} \left(\frac{d}{d t} θ{\left(t \right)}\right)^{2}}{2} - \frac{l \cos{\left(θ{\left(t \right)} \right)} \frac{d^{2}}{d t^{2}} θ{\left(t \right)}}{2}\)
<p>y</p>
\(\frac{d^{2}}{d t^{2}} θ = - \frac{3 g \sin{\left(θ{\left(t \right)} \right)} + 3 \cos{\left(θ{\left(t \right)} \right)} \frac{d^{2}}{d t^{2}} x{\left(t \right)}}{2 l}\)
<p>Definimos una función de la siguiente forma en donde únicamente transcribiremos esas ecuaciones a código, hay que ser cuidadosos en respetar la estructura. Tomamos de una vez \(l = 1\) para que se vea más limpio el código.</p>
<pre><code class=language-julia >function cuerpo_rigido&#40;ddu, du, u, p, t&#41;
    g, l, Ω &#61; p


    ddu&#91;1&#93; &#61; &#40;g * cos&#40;t * Ω&#41; / 3&#41; &#43; &#40;sin&#40;u&#91;2&#93;&#41; * du&#91;2&#93;^2 / 2&#41; - &#40;cos&#40;u&#91;2&#93;&#41; * ddu&#91;2&#93; / 2&#41;
    ddu&#91;2&#93; &#61; -3/2 * &#40;g * sin&#40;u&#91;2&#93;&#41; &#43; cos&#40;u&#91;2&#93;&#41; * ddu&#91;1&#93;&#41; 
end</code></pre>
<pre><code class="plaintext code-output">cuerpo_rigido (generic function with 1 method)</code></pre>
<p>Definimos nuestras condiciones iniciales, tal cual se nos pide.</p>
<pre><code class=language-julia >u0 &#61; &#91;0.0, 0.0&#93;
du0 &#61; &#91;0.0, 0.0&#93;</code></pre>
<p>Y ahora definimos el problema de la siguiente forma:</p>
<pre><code class=language-julia >prob_CR &#61; SecondOrderODEProblem&#40;cuerpo_rigido, du0, u0, tspan, params&#41;</code></pre>
<pre><code class=language-julia >ODEProblem with uType RecursiveArrayTools.ArrayPartition&#123;Float64, Tuple&#123;Vector&#123;Float64&#125;, Vector&#123;Float64&#125;&#125;&#125; and tType Float64. In-place: true
timespan: &#40;0.0, 10.0&#41;
u0: &#40;&#91;0.0, 0.0&#93;, &#91;0.0, 0.0&#93;&#41;</code></pre>
<p>Eso significa que todo va bien, que tenemos bien definido nuestro problema con ese span de tiempo, y esas condiciones iniciales.</p>
<p>Ahora, ya se ha discutido <a href="https://marcoherrera-s.github.io/Problemas/Ejercicios/oscilador/">aquí</a>, que resolver ecuaciones diferenciales numéricamente, por lo regular no es tan sencillo como oprimir el botón resolver y listo, hay que tener una idea clara del problema que estamos resolviendo, qué nos interesa del problema, y sobre todo, que tipo de algoritmos existen. </p>
<p>Supongamos que ingenuamente, simplemente le damos a resolver:</p>
<pre><code class=language-julia >sol_CR_ingenuo &#61; solve&#40;prob_CR&#41;</code></pre>
<p>Muy bien, ahora grafiquemos lo que obtuvimos haciendo:</p>
<pre><code class=language-julia >ingenuo &#61; plot&#40;sol_CR_ingenuo&#41;</code></pre>
<p><img src="/blog/assets/ingenuo.png" alt=ingenuo  /></p>
<p>Nuestra gráfica no tiene ningun sentido.  Entonces, lo que está pasando es que nos estamos enfrentando a un sistema de ecuaciones diferenciales del tipo <em>stiff</em> o <em>rígidas</em> en español.  Este tipo de ecuaciones diferenciales son todo un mundo, sobre el cual pueden saber más <a href="https://en.wikipedia.org/wiki/Stiff_equation">aquí</a>, <a href="https://scicomp.stackexchange.com/questions/891/the-definition-of-stiff-ode-system">aquí</a> y <a href="https://docs.sciml.ai/SciMLTutorialsOutput/html/introduction/02-choosing_algs.html">aquí</a>. Entre muchos más lados. </p>
<p>Pero en esencia lo que está pasando es que los algoritmos tradicionales no funcionan correctamente.</p>
<p>Lo que podemos hacer es ir al siguiente <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/#OrdinaryDiffEq.jl-for-Stiff-Equations">enlace</a>, y buscar algún algoritmo especializado para este tipo de ecuaciones.</p>
<p>Aquí usaremos el algoritmo KenCarp47&#40;&#41;, este es un método ESDIRK <em>&#40;Explicit Singly Diagonally Implicit Runge Kutta&#41;</em>, de siete etapas de cuarto orden. Este método es parte de una <a href="https://arxiv.org/abs/1803.01613">familia de algoritmos</a> que están diseñados para manejar ecuaciones diferenciales rígidas. Aumentaremos el número máximo de iteraciones sólo por si las moscas. </p>
<p>Entonces hagamos: </p>
<pre><code class=language-julia >prob_CR &#61; SecondOrderODEProblem&#40;cuerpo_rigido, du0, u0, tspan, params&#41;</code></pre>
<pre><code class=language-julia >ODEProblem with uType RecursiveArrayTools.ArrayPartition&#123;Float64, Tuple&#123;Vector&#123;Float64&#125;, Vector&#123;Float64&#125;&#125;&#125; and tType Float64. In-place: true
timespan: &#40;0.0, 10.0&#41;
u0: &#40;&#91;0.0, 0.0&#93;, &#91;0.0, 0.0&#93;&#41;</code></pre>
<pre><code class=language-julia >sol_CR&#61; solve&#40;prob_CR, KenCarp47&#40;&#41;, maxiters&#61;1e7&#41;
sol_CR&#91;1:5&#93;</code></pre>
<pre><code class=language-julia >retcode: Success
Interpolation: 3rd order Hermite
t: 5-element Vector&#123;Float64&#125;:
 0.0
 2.4999999999999998e-5
 0.00027499999999999996
 0.0027749999999999993
 0.0043374999999999985
u: 5-element Vector&#123;RecursiveArrayTools.ArrayPartition&#123;Float64, Tuple&#123;Vector&#123;Float64&#125;, Vector&#123;Float64&#125;&#125;&#125;&#125;:
 &#40;&#91;0.0, 0.0&#93;, &#91;0.0, 0.0&#93;&#41;
 &#40;&#91;0.00032685999214312615, -0.0004902899874999309&#93;, &#91;4.085969522329402e-9, -6.128954279218507e-9&#93;&#41;
 &#40;&#91;0.0035968144933999965, -0.0053952207395484945&#93;, &#91;4.945460046962802e-7, -7.418189382655796e-7&#93;&#41;
 &#40;&#91;0.036294755093382966, -0.05444110440780338&#93;, &#91;5.035995617645005e-5, -7.553922093387915e-5&#93;&#41;
 &#40;&#91;0.056724601745096526, -0.0850829759189515&#93;, &#91;0.0001230322224232393, -0.00018454407565608402&#93;&#41;</code></pre>
<p>Y además, para comparar, podemos hacer la comparación con lo que sería el sistema aproximado, es decir, haciendo: </p>
\(\sin{x} = x\)
<p>y </p>
\(\cos{x} = 1\)
<p>Por lo que nuestro sistema aproximado nos quedaría:</p>
<pre><code class=language-julia >function cuerpo_rigido_aproxx&#40;ddu, du, u, p, t&#41;
    g, l, Ω &#61; p


    ddu&#91;1&#93; &#61; &#40;g * cos&#40;t * Ω&#41; / 3&#41; &#43; &#40;u&#91;2&#93; * du&#91;2&#93;^2 / 2&#41; - &#40;ddu&#91;2&#93; / 2&#41;
    ddu&#91;2&#93; &#61; -3/2 * &#40;g * u&#91;2&#93; &#43; ddu&#91;1&#93;&#41; 
end</code></pre>
<pre><code class="plaintext code-output">cuerpo_rigido_aproxx (generic function with 1 method)</code></pre>
<p>Y resolviendo con las mismas condiciones, tendríamos:</p>
<pre><code class=language-julia >prob_CR_aproxx &#61; SecondOrderODEProblem&#40;cuerpo_rigido_aproxx, du0, u0, tspan, params&#41;</code></pre>
<pre><code class=language-julia >ODEProblem with uType RecursiveArrayTools.ArrayPartition&#123;Float64, Tuple&#123;Vector&#123;Float64&#125;, Vector&#123;Float64&#125;&#125;&#125; and tType Float64. In-place: true
timespan: &#40;0.0, 10.0&#41;
u0: &#40;&#91;0.0, 0.0&#93;, &#91;0.0, 0.0&#93;&#41;</code></pre>
<pre><code class=language-julia >sol_CR_aproxx &#61; solve&#40;prob_CR_aproxx, KenCarp47&#40;&#41;, maxiters&#61;1e7&#41;
sol_CR_aproxx&#91;1:5&#93;</code></pre>
<p>Ahora, graficando en primer lugar la posición del punto, tanto la solución numérica como la solución aproximada tendríamos:</p>
<pre><code class=language-julia >plot&#40;sol_m, idxs &#61; &#40;0, 2&#41;, color&#61;:black, label&#61;&quot;Numérico&quot;, dpi&#61;500&#41;
plot&#33;&#40;sol_m_aprox, idxs &#61; &#40;0, 2&#41;, linestyle&#61;:dash, label&#61;&quot;Aproximación&quot;, ylabel&#61;&quot;Posición del punto&quot;, ylims&#61;&#40;-7,7&#41;, color&#61;:red, title&#61;&quot;Posición del punto en cuerpo rígido&quot;&#41;</code></pre>
<p>Y obtenemos:</p>
<p><img src="/blog/assets/pospunto.png" alt=poscr  /></p>
<p>De la misma forma podemos graficar los demás resultados. El índice 0 es el tiempo, el 1 la velocidad del punto, el 2 es la posición del punto como se hizo para graficar el resultado anterior, el índice 3 es la velocidad del ángulo, y el índice 4 es el valor del ángulo, entonces tendríamos:</p>
<p><img src="/blog/assets/velpunto.png" alt=velpu  /></p>
<p><img src="/blog/assets/velangulo.png" alt=velangu  /></p>
<p><img src="/blog/assets/anguba.png" alt=valan  /></p>
<p>Y como podemos observar, obtenemos movimientos oscilatorios, y también, como era de esperarse, las solución numérica y la aproximada se parecen demasiado recién comienza el sistema. </p>

<span style="color: darkgreen; font-size: 35px; font-family: 'Helvetica';">¿Por qué todo lo que está arriba está mal?</span>

<p>Bueno, casi todo...</p>
<div class=page-foot  style="font-size: 13px; font-family: 'Sans-serif', Arial, sans-serif;">
    <a</a> Marco Herrera Solar. Last modified: July 31, 2024.
    Sitio hecho con <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> y <a href="https://julialang.org">Julia programming language</a>.
</div>

</div>
        </div> 
    </div> 
    
        <script src="/blog/libs/katex/katex.min.js"></script>
<script src="/blog/libs/katex/contrib/auto-render.min.js"></script>
<script>
    renderMathInElement(document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "\\(", right: "\\)", display: false},
            {left: "\\[", right: "\\]", display: true} // Añade este delimitador para las ecuaciones en bloque
        ],
        linebreaks: { automatic: true } // Habilita los saltos de línea automáticos
    });
</script>

    
    
        <script src="/blog/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>